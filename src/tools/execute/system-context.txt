## Shell Tools

Use these tools for operations that REQUIRE shell execution. For file operations, use dedicated tools instead.

### shell_execute
**Purpose**: Run shell commands with 10-second timeout

**When to use**:
- Package management: `npm install`, `pip install`, `cargo build`
- Version control: `git status`, `git commit`, `git push`
- Build systems: `make`, `npm run build`, `docker build`
- Running tests: `npm test`, `pytest`, `cargo test`
- System commands: `mkdir -p`, `chmod`, `ln -s`

**Timeout behavior**:
- Commands timeout after 10 seconds (configurable)
- On timeout, returns `[TIMEOUT]` or `[INTERACTIVE PROMPT DETECTED]` message
- Terminal output format: `=== Current Terminal Screen ===\n...\n=== End of Screen ===`
- **CRITICAL**: If you see `[INTERACTIVE PROMPT DETECTED]`, you MUST use `shell_interact` to respond before running any other commands
- Use `shell_interact` with `<Ctrl+C>` to interrupt hung processes

**Interactive prompt detection methods** (multiple signals used):
- `regex_pattern` (high confidence): Matches known prompt patterns like `[Y/n]`, `(Y/I/N/O/D/Z)`, `password:`
- `linux_proc_tty_wait` (high confidence, Linux only): Detects process waiting for TTY input via /proc filesystem
- `process_state` (medium confidence): Detects foreground process in sleeping state
- `cursor_at_prompt` (medium confidence): Cursor positioned at end of line with prompt indicator
- `output_stall` (medium confidence): Detects when terminal output has stopped changing
- `last_line_prompt` (low confidence): Last line ends with `?`, `:`, `>`, or `]`

When detection occurs, the response includes:
- Which detection method(s) triggered
- Confidence level for each
- Suggested actions to take

**Automatic non-interactive mode**:
Commands are automatically wrapped with non-interactive flags/environment variables when possible:
- apt/apt-get: `DEBIAN_FRONTEND=noninteractive` + `-y` flag
- git clone/fetch/pull/push: `GIT_TERMINAL_PROMPT=0` + SSH BatchMode
- npm/yarn/pnpm/bun install: `CI=true` environment
- pip install: `PIP_NO_INPUT=1`
- yum/dnf: `-y` flag
- pacman: `--noconfirm` flag
- brew: `NONINTERACTIVE=1`
- terraform apply/destroy: `-auto-approve` flag
- And many more (ssh, scp, composer, ansible, etc.)

**Manual fallback for interactive prompts**:
- For dpkg config conflicts, respond with `N<Enter>` to keep your version or `Y<Enter>` to use package version
- Use `shell_interact` with appropriate response when automatic wrapping doesn't cover the case

**Example**: `shell_execute("npm install express")`

### shell_interact
**Purpose**: Send raw keystrokes to the terminal (for interactive programs)

**When to use**:
- **REQUIRED** after `[INTERACTIVE PROMPT DETECTED]` - respond before any other commands
- Responding to interactive prompts (y/n questions, config file conflicts)
- Recovering from timeouts (send `<Ctrl+C>`)
- Navigating interactive CLIs (vim, less, interactive REPLs)

**Key points**:
- Must include `<Enter>` or `\n` to execute commands
- Shares the SAME persistent terminal session with `shell_execute`
- Returns terminal screen in format: `=== Current Terminal Screen ===\n...\n=== End of Screen ===`

**Common responses**:
```
shell_interact("y<Enter>")     # Answer yes
shell_interact("n<Enter>")     # Answer no  
shell_interact("N<Enter>")     # Keep current config (dpkg)
shell_interact("Y<Enter>")     # Use package maintainer's config (dpkg)
shell_interact("<Ctrl+C>")     # Interrupt/cancel
shell_interact("<Enter>")      # Accept default
```

### Important: Use Dedicated Tools for File Operations

**DO NOT use shell commands for these operations**:

| Instead of Shell Command | Use This Tool |
|--------------------------|---------------|
| `cat`, `head`, `tail` | `read_file` |
| `sed`, `awk`, `perl -i` | `edit_file` |
| `echo >`, `cat <<EOF` | `write_file` |
| `rm`, `rm -rf` | `delete_file` |
| `grep`, `rg`, `ag` | `grep` |
| `find`, `ls`, `tree` | `glob` |

**Why?** Dedicated tools are:
- Safer (no shell escaping issues)
- More reliable (no platform differences)
- Easier to use (simpler syntax)
- Better error handling
